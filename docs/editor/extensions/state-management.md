---
sidebar_position: 1
---

# 상태 관리

이 페이지는 [편집기 확장](index.md)을 위한 상태 관리에 대한 소개를 제공합니다.

:::note
이 페이지는 Obsidian 플러그인 개발자를 위한 공식 CodeMirror 6 문서를 단순화한 내용입니다. 상태 관리에 대한 자세한 정보는 [State and Updates](https://codemirror.net/docs/guide/#state-and-updates)를 참조하세요.
:::

## 상태 변경

대부분의 애플리케이션에서는 속성 또는 변수에 새 값을 할당하여 상태를 업데이트합니다. 이로 인해 이전 값은 영원히 손실됩니다.

```ts
let note = "";
note = "Heading";
note = "# Heading";
note = "## Heading"; // 이걸 어떻게 되돌릴까요?
```

사용자의 작업 공간에 대한 변경 사항을 실행 취소하고 다시 실행하는 기능과 같은 기능을 지원하기 위해, Obsidian과 같은 애플리케이션에서는 변경 사항의 모든 기록을 유지합니다. 변경 사항을 실행 취소하려면 변경 사항이 발생하기 전의 시점으로 돌아갈 수 있습니다.

|     | State      |
| --- | ---------- |
| 0   |            |
| 1   | Heading    |
| 2   | # Heading  |
| 3   | ## Heading |

TypeScript에서는 다음과 같이 작성됩니다.

```ts
const changes: ChangeSpec[] = [];

changes.push({ from: 0, insert: "Heading" });
changes.push({ from: 0, insert: "# " });
changes.push({ from: 0, insert: "#" });
```

## 트랜잭션

선택한 텍스트를 선택한 후 이중 인용부호 `"`를 눌러 양쪽에 인용 부호로 묶는 기능을 상상해보세요. 이 기능을 구현하는 한 가지 방법은 다음과 같습니다.

1. 선택 영역의 시작 부분에 `"`를 삽입합니다.
2. 선택 영역의 끝 부분에 `"`를 삽입합니다.

구현은 *두 개*의 상태 변경으로 구성되어 있음을 알 수 있습니다. 이러한 변경 사항을 실행 취소 기록에 추가하면 사용자는 각각의 이중 인용부호마다 실행 취소를 _두 번_ 해야 합니다. 이를 피하기 위해 변경 사항들이 하나로 보이도록 그룹화할 수 있다면 어떨까요?

편집기 확장에서 함께 발생하는 일련의 상태 변경 그룹은 *트랜잭션(transaction)*이라고 합니다.

지금까지 배운 내용을 종합하여, 단일 상태 변경만 포함하는 트랜잭션이 가능하도록 상태를 *트랜잭션의 기록(history)*으로 간주할 수 있습니다.

앞에서 언급한 이전 예제에서 편집기 확장에서 surround 기능을 구현하기 위해 에디터 뷰에 트랜잭션을 추가하거나 *디스패치*하는 방법은 다음과 같습니다.

```ts
view.dispatch({
    changes: [
        { from: selectionStart, insert: `"` },
        { from: selectionEnd, insert: `"` },
    ],
});
```

## 다음 단계

이 페이지에서는 상태를 일련의 상태 변경으로 모델링하고, 이를 트랜잭션으로 그룹화하는 방법에 대해 배웠습니다.

편집기에서 사용자 정의 상태를 관리하는 방법을 알아보려면 [상태 필드](state-fields.md)를 참조하세요.
